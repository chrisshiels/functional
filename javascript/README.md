# functional/javascript

Implementations of common functional programming functions in JavaScript:
all, any, flatten, range, reduce, scan, map, filter, partition, permutations,
split, reverse, sort, unique, zip, zipwith, group, flip, compose, pipe,
pipemaybe, pipeeither, partial, curry and memoize.


    host$ npm install
    host$ npm test

    > functional@1.0.0 test /home/chris/github.com/functional/javascript
    > mocha



      functional
        #all()
          ✓ returns false for all(divisibleby2, [])
          ✓ returns true for all(divisibleby2, [ 2, 4, 6, 8, 10 ])
          ✓ returns false for all(divisibleby3, [ 2, 4, 6, 8, 10 ])
        #any()
          ✓ returns false for any(divisibleby2, [])
          ✓ returns true for any(divisibleby2, [ 2, 4, 6, 8, 10 ])
          ✓ returns true for any(divisibleby3, [ 2, 4, 6, 8, 10 ])
        #flatten()
          ✓ returns [] for flatten([])
          ✓ returns [ 1, 2, 3 ] for flatten([ 1, 2, 3 ])
          ✓ returns [ 1, 2, 3 ] for flatten([[ 1, 2 ], 3])
          ✓ returns [ 1, 2, 3 ] for flatten([1, [ 2, 3 ]])
          ✓ returns [ 1, 2, 3 ] for flatten([1, [ 2, [ 3 ] ] ])
          ✓ returns [ 1, 2, 3 ] for flatten([ [ [ 1 ], [ 2 ], [ 3 ] ] ])
        #range()
          ✓ returns [] for range(0)
          ✓ returns [ 0..9 ] for range(10)
          ✓ returns [ 0..9 ] for range(0, 10)
          ✓ returns [ 0..9 ] for range(0, 10, 1)
          ✓ returns [ 0,2,4,6,8 ] for range(0, 10, 2)
          ✓ returns [ 0,3,6,9 ] for range(0, 10, 3)
          ✓ returns [ 10..1 ] for range(10, 0, -1)
          ✓ returns [ 1..10 ] for range(1, 11)
        #reduce()
          ✓ returns 55 for reduce((a, e) => { return a + e; }, range(1, 11), 0)
          ✓ returns 55 for reduce((a, e) => { return a + e; }, range(1, 11))
          ✓ returns [ 1, 2, 3, 4, 5, 6 ] for reduce((a, e) => { return a.concat(e); }, [ [ 1 ], [ 2, 3 ], [ 4, 5, 6 ] ])
          ✓ returns 6 for reduce((a, e) => { return a + e.length; }, [ [ 1 ], [ 2, 3 ], [ 4, 5, 6 ] ], 0)
        #map()
          ✓ returns [ 2,4,6..20 ] for map((e) => { return e * 2; }, range(1, 11))
          ✓ returns [ [ 1 ], [ 2 ], [ 3 ] ] for map((e) => { return e; }, [ [ 1 ], [ 2 ], [ 3 ] ])
        #filter()
          ✓ returns [ 2, 4, 6, 8, 10 ] for filter((e) => { return e % 2 === 0; }, range(1, 11))
          ✓ returns [ 1, 3, 5, 7, 9 ] for filter((e) => { return e % 2 === 1; }, range(1, 11))
          ✓ returns [ [ 1 ], [ 2 ], [ 3 ] ] for filter((e) => { return e.length !== 0; }, [ [ 1 ], [], [ 2 ], [], [ 3 ] ])
        #partition()
          ✓ returns [ [ 3, 6, 9 ], [ 1, 2, 4, 5, 7, 8, 10 ] ] for partition((e) => { return e % 3 === 0; }, range(1, 11))
          ✓ returns [ [ 1, 2, 4, 5, 7, 8, 10 ], [ 3, 6, 9 ] ] for partition((e) => { return e % 3 !== 0; }, range(1, 11))
          ✓ returns [ [], [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] ] for partition((e) => { return e === 0; }, range(1, 11))
          ✓ returns [ [ [ 1, 2 ], [ 1, 2, 3 ] ], [ [ 1 ] ] ] for partition((e) => { return e.length > 1; }, [ [ 1 ], [ 1, 2 ], [ 1, 2, 3 ] ])
        #split()
          ✓ returns [] for split((e) => { return e % 10 === 0; }, [])
          ✓ returns [] for split((e) => { return e % 1 === 0; }, range(1, 11))
          ✓ returns [ [ 1 ], [ 3 ], [ 5 ], [ 7 ], [ 9 ] ] for split((e) => { return e % 2 === 0; }, range(1, 11))
          ✓ returns [ [ 1, 2 ], [ 4, 5 ], [ 7, 8 ], [ 10 ] ] for split((e) => { return e % 3 === 0; }, range(1, 11))
        #reverse()
          ✓ returns [ 10..1 ] for reverse(range(1, 11))
          ✓ returns [ [ 5, 6 ], [ 3, 4 ], [ 1, 2 ] ] for reverse([ [ 1, 2 ], [ 3, 4 ], [ 5, 6 ] ])
        #sort()
          ✓ returns [ 1..10 ] for sort((m, n) => { return m <= n; }, [ 1, 10, 2, 9, 3, 8, 4, 7, 5, 6 ])
          ✓ returns [ [ 1 ], [ 1, 2 ],  [ 1, 2, 3 ] ] for sort((m, n) => { return m.length <= n.length; }, [ [ 1, 2, 3], [ 1, 2 ], [ 1 ] ])
        #unique()
          ✓ returns [ 5, 1, 4, 2, 3 ] for unique([ 5, 1, 4, 2, 3, 3, 2, 4, 1, 5 ])
        #zip()
          ✓ returns [ [ 1, 5 ], [ 2, 6 ], [ 3, 7 ], [ 4, 8 ] ] for zip(...[ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ] ])
          ✓ returns [ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ] ] for zip(...zip(...[ [ 1, 2, 3, 4 ], [ 5, 6, 7, 8 ] ]))
        #permutations()
          ✓ returns [] for permutations([])
          ✓ returns [ [ 1 ] ] for permutations([ 1 ])
          ✓ returns [ [ 1, 2 ], [ 2, 1 ] ] for permutations([ 1, 2 ])
          ✓ returns [ [ 1, 2, 3 ] .. [ 3, 2, 1 ] ] for permutations([ 1, 2, 3 ])
          ✓ returns [ [ 1, 2, 3, 4 ] .. [ 4, 3, 2, 1 ] ] for permutations([ 1, 2, 3, 4 ])
        #compose()
          ✓ returns 3 for compose(valueadd1, valuemultiply2)(1)
        #pipe()
          ✓ returns 5 for pipe([ valueadd1, valuemultiply2, valueadd1 ])(1)
          ✓ returns [ 5, 7, 9, 11, 13, 15, 17, 19, 21, 23 ] for pipe([ listadd1, listmultiply2, listadd1 ])(range(1, 11))
        #pipe2()
          ✓ returns 5 for pipe2([ valueadd1, valuemultiply2, valueadd1 ])(1)
          ✓ returns [ 5, 7, 9, 11, 13, 15, 17, 19, 21, 23 ] for pipe2([ listadd1, listmultiply2, listadd1 ])(range(1, 11))
        #pipemaybe()
          ✓ returns 3 for pipemaybe([ valueadd1, valueadd1, valueadd1 ])(0)
          ✓ returns null for pipemaybe([ valueadd1, valuenull, valueadd1 ])(0)
        #partial()
          ✓ returns [ 11..20 ] for map(partial(add, 10), range(1, 11))
        #curry()
          ✓ supports multiple execution paths
          ✓ returns 15 for curry(add)(10)(5) and 25 for curry(add)(20)(5)
          ✓ returns [ 11..20 ] for map(curry(add)(10), range(1, 11))
        #factorial()
          ✓ returns [ 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800 ] for map(factorial, range(1, 11))
        #fibonacci()
          ✓ returns [ 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 ] for map(fibonacci, range(1, 11))
        #memoizedfibonacci()
          ✓ returns 20365011074 for memoizedfibonacci(50)
        #primes()
          ✓ returns [ 2, 3, 5, 7, 11, 13, 17, 19 ] for primes(20)
        #ispalindrome()
          ✓ returns true for ispalindrome('tattarrattat')


      65 passing (15ms)
